{"/":{"title":"Gabriel Chan's website","content":"\nHi, this is my website where I keep my notes for research and class, and maybe projects in the future. \n\n## Content Lists\n- [Research](/notes)\n\n\n\n","lastmodified":"2022-06-20T16:21:07.626675865Z","tags":null},"/notes/openPCDet":{"title":"OpenPCDet","content":"# OpenPCDet \n\n## Code Architecture \nfile structure for a project should look something like this:\n\n### Directories\n```bash\nOpenPCDet (or proj name)\n├── data \n│   ├── kitti\n│   ├── lyft\n│   └── waymo\n├── docker\n├── docs\n├── pcdet\n│   ├── datasets\n│   ├── models\n│   ├── ops\n│   └── utils\n└── tools\n    ├── cfgs\n    ├── eval_utils\n    ├── scripts\n    ├── train_utils\n    └── visual_utils\n```\n\n\n\n","lastmodified":"2022-06-20T16:21:07.674675928Z","tags":null},"/notes/papers/3DSSD":{"title":"3DSSD: Point-based 3D Single Stage Object Detector","content":"\n[arXiv link](https://arxiv.org/pdf/2002.10187.pdf) \ngithub #todo \n\n\n## Main Ideas:\n-  Introduced **Feature-Farthest Point Sampling (F-FPS)**\n- Introduced new sampling method called **Fusion Sampling** in [[notes/papers/PointNet++#Set Abstraction SA Layer]]\n\n\n### Feature-Farthest Point Sampling (F-FPS)\n- Objective when downsample: \n\t1. Remove **negative points** (background points) \n\t2. Preserve only **positive points** (foreground points, i.e: points within any instance := ground truth box)\n- Therefore leverage semantic features of points as well when applying FPS \n- Given two points $A$ and $B$, the criterion used to compare them in FPS is:$$C(A,B)=\\lambda L_d(A,B)+L_f(A,B)$$\n\t\twhere \n\t\t- $L_d(A,B)$ is $L^2$ euclidean distance (xyz) \n\t\t- $L_f(A,B)$ is $L^2$ feature distance (distance between the two feature vectors)\n\t\t- $\\lambda$ is chosen parameter, paper seems to choose $\\lambda=1$\n\t\t- *reminder*: $L^2(A,B)= \\sqrt{(B_1-A_1)^2+(B_1-A_1)^2+\\cdots+(B_n-A_n)^2}$  if $A$ and $B$ are $n$ dimensional vectors\n- Result should be a subset of points that are less redundant and more diverse, as points are not only physically distant when sampling, but also in feature space.  \n\n### Fusion Sampling\n- Downsampling to $N_m$ points with **F-FPS** results in:\n\t\t- lots of positive points -\u003e good for regression \n\t\t- few negative points (due to limiting ) -\u003e bad for classification\n\t\t- **Why?** Negative points don't have enough neighbours #expand \n- Input: $N_i\\times C_i :=$ $N$ points each with feature vector of length $C$\n- want to output $N_{i+1}$ points, where $N_{i+1}$ points are subset of the $N_i$ points\n\t1. F-FPS$: N_i \\to \\frac{N_{i+1}}{2}$ #Q\n\t2. D-FPS:$N_i \\to \\frac{N_{i+1}}{2}$ #Q\n\t3. grouping operation ([[notes/papers/PointNet++#Grouping Layer]])\n\t4. MLP\n\t5. MaxPool\n\n![[notes/images/3dssd_backbone.png]]\n#### SA1\n$[16384 \\times 4] \\to [4096 \\times 128]$\n\n####  SA2 \n$[4096 \\times 128]\\to [512\\times 256],[512\\times 256]$\n\n\n\n","lastmodified":"2022-06-20T16:21:07.674675928Z","tags":null},"/notes/papers/PointNet++":{"title":"PointNet++","content":"\n\n## Set Abstraction (SA) Layer\n![[notes/images/pointnet2.png]]\n\n### Sampling Layer \nLets call the sampling layer $SL$.\n- Input: $N\\times 3$ \n\t- N points with $x,y,z$\n- Output: $M\\times 3$ \n\t- $M$ points with $x,y,z$ where points in $M$ are subset of $N$\n- Method: **Iterative Farthest Point Sampling** (FPS)\n\t1. Start by choosing 1 random point\n\t2. Calculate distance for all remaining points to selected points.\n\t\t1. so each point will have an array keeping track of the distances $$dist_i:[dist\\_to\\_selected_0,dist\\_to\\_selected_1,\\ldots]$$\n\t\t   for example:$$dist_0=[1.1,3.5,25,23]$$\n\t\t   would be point $0$ and its distance to the four selected points.\n\t\t3. take the minimum of the arrray, i.e. for each remaining point, set its distance to the closest selected point. for exmaple, $$\\begin{align}\n\t\t   dist_0 = 1.1\n\t\t\\end{align}$$\n\t\t4. Finally, select the point with the greatest distance\n\t3. Repeat step 2 $M-1$ more times\u003e)\n\n### Grouping Layer\n- Sampling Layer $SL$ yields $N'\\times 3$ points.\n\t- $N'$ centroids and $3:= x,y,z$ coordinates \n\t- $SL:(N\\times 3) \\to (N'\\times 3)$\n- Input: \n\t- $(N\\times 3+ C)$: points before sampling and their feature vectors of len $C$\n\t-  $(N'\\times d)$: predicted centroids \n- Output: \n\t- $(N'\\times K \\times (3+C))$: centroid + $K$ points within radius of $r$ along their features\n- Method: \n\t- Ball query\n\t\t\t- what if points within radius is $\u003cK$? \n\t\t\t- what if no points (only centroid point)?\n\t\t\t- with if more than $K$ points?  ","lastmodified":"2022-06-20T16:21:07.674675928Z","tags":null},"/tags/setup":{"title":"","content":"","lastmodified":"2022-06-20T16:21:07.674675928Z","tags":null}}